/**
 * Galaxy Sprint - Batallas Espaciales
 * 
 * Punto de entrada principal de la aplicaciÃ³n.
 * Maneja el menÃº principal y coordina todas las funcionalidades del juego.
 * 
 * @author Daniel Santiago
 * @version 2.0.0
 */

// Importaciones de librerÃ­as externas
import inquirer from 'inquirer';           // Para menÃºs interactivos de consola
import { v4 as uuidv4 } from 'uuid';       // Para generar IDs Ãºnicos

// Importaciones de modelos (entidades del juego)
import { ExploradorHumano } from './models/ExploradorHumano.js';
import { ExploradorGuerrero } from './models/ExploradorGuerrero.js';
import { ExploradorMago } from './models/ExploradorMago.js';
import { ExploradorArquero } from './models/ExploradorArquero.js';

// Importaciones de servicios (lÃ³gica de negocio)
import { NotificadorCLI } from './services/NotificadorCLI.js';
import { GestorBatalla } from './services/GestorBatalla.js';
import { GestorGuardado } from './services/GestorGuardado.js';
import { GeneradorEnemigos } from './services/GeneradorEnemigos.js';

// Importaciones de items del inventario
import { Pocion } from './models/items/Pocion.js';
import { Arma } from './models/items/Arma.js';
import { Armadura } from './models/items/Armadura.js';
import { Energia } from './models/items/Energia.js';

/**
 * FunciÃ³n principal de la aplicaciÃ³n.
 * Inicializa los servicios necesarios y maneja el bucle principal del menÃº.
 * 
 * Aplica el principio SRP (Single Responsibility Principle) al coordinar
 * diferentes servicios sin implementar lÃ³gica especÃ­fica de cada uno.
 */
async function main() {
    // InicializaciÃ³n de servicios principales (DIP - Dependency Inversion Principle)
    const notificador = new NotificadorCLI();      // Manejo de notificaciones
    const gestorGuardado = new GestorGuardado();   // Persistencia de datos
    const generadorEnemigos = new GeneradorEnemigos(); // GeneraciÃ³n de enemigos
    
    // Inicializar sistema de guardado
    try {
        await gestorGuardado.inicializar();
        notificador.success('Sistema de guardado inicializado correctamente');
    } catch (error) {
        notificador.error(`Error inicializando guardado: ${error.message}`);
    }

    let exit = false; // Control del bucle principal

    // Bucle principal del menÃº (aplicando principio de responsabilidad Ãºnica)
    while (!exit) {
        const { opcion } = await inquirer.prompt([{
            type: 'list',
            name: 'opcion',
            message: 'ðŸš€ Galaxy Sprint â€” Batallas Espaciales ðŸš€',
            choices: [
                { name: 'Crear nuevo personaje', value: 'crear' },
                { name: 'Cargar personaje existente', value: 'cargar' },
                { name: 'Ver personajes guardados', value: 'listar' },
                { name: 'Iniciar batalla', value: 'batalla' },
                { name: 'Ver estadÃ­sticas', value: 'stats' },
                { name: 'Ver instrucciones', value: 'help' },
                { name: 'Salir', value: 'salir' }
            ]
        }]);

        // Router de opciones (aplicando principio Open/Closed)
        switch (opcion) {
            case 'crear':
                await crearPersonaje(gestorGuardado, notificador);
                break;
            case 'cargar':
                await cargarPersonaje(gestorGuardado, notificador);
                break;
            case 'listar':
                await listarPersonajes(gestorGuardado, notificador);
                break;
            case 'batalla':
                await iniciarBatalla(gestorGuardado, generadorEnemigos, notificador);
                break;
            case 'stats':
                await mostrarEstadisticas(gestorGuardado, notificador);
                break;
            case 'help':
                mostrarAyuda(notificador);
                break;
            case 'salir':
                exit = true;
                break;
        }
    }

    notificador.info('Â¡Gracias por jugar Galaxy Sprint! ðŸ‘‹');
}

/**
 * Crea un nuevo personaje del juego.
 * 
 * Aplica el principio OCP (Open/Closed Principle) al permitir aÃ±adir nuevas clases
 * de personaje sin modificar esta funciÃ³n, solo extendiendo el switch.
 * 
 * @param {GestorGuardado} gestorGuardado - Servicio para guardar el personaje
 * @param {NotificadorCLI} notificador - Servicio para mostrar mensajes
 */
async function crearPersonaje(gestorGuardado, notificador) {
    // Recopilar informaciÃ³n del usuario
    const { nombre, clase } = await inquirer.prompt([
        {
            type: 'input',
            name: 'nombre',
            message: 'Nombre del explorador:',
            default: 'Jugador'
        },
        {
            type: 'list',
            name: 'clase',
            message: 'Selecciona la clase de tu explorador:',
            choices: [
                { name: 'Humano - Equilibrado (Vida: 120, Ataque: 12, Defensa: 8)', value: 'Humano' },
                { name: 'Guerrero - Tanque (Vida: 150, Ataque: 18, Defensa: 12)', value: 'Guerrero' },
                { name: 'Mago - Hechicero (Vida: 80, Ataque: 15, Defensa: 4, EnergÃ­a: 100)', value: 'Mago' },
                { name: 'Arquero - Velocidad (Vida: 100, Ataque: 14, Velocidad: 12)', value: 'Arquero' }
            ]
        }
    ]);

    // Crear instancia del personaje segÃºn la clase seleccionada
    let personaje;
    const datosBase = { id: uuidv4(), nombre }; // ID Ãºnico para el personaje

    // Factory pattern para crear personajes (aplicando LSP - Liskov Substitution Principle)
    switch (clase) {
        case 'Humano':
            personaje = new ExploradorHumano(datosBase);
            break;
        case 'Guerrero':
            personaje = new ExploradorGuerrero(datosBase);
            break;
        case 'Mago':
            personaje = new ExploradorMago(datosBase);
            break;
        case 'Arquero':
            personaje = new ExploradorArquero(datosBase);
            break;
    }

    // Dar items iniciales al personaje (composiciÃ³n)
    personaje.agregarItem(new Pocion({ 
        id: uuidv4(), 
        nombre: 'PociÃ³n de Vida', 
        descripcion: 'Restaura 30 puntos de vida', 
        curacion: 30 
    }));
    personaje.agregarItem(new Energia({ 
        id: uuidv4(), 
        nombre: 'Bebida EnergÃ©tica', 
        descripcion: 'Restaura 20 puntos de energÃ­a', 
        bonusEnergia: 20 
    }));

    // Persistir el personaje y notificar Ã©xito
    await gestorGuardado.guardarPersonaje(personaje);
    notificador.success(`Â¡Personaje ${nombre} (${clase}) creado exitosamente!`);
}

/**
 * Carga y muestra informaciÃ³n de un personaje existente.
 * 
 * Aplica el principio SRP al manejar Ãºnicamente la carga y visualizaciÃ³n
 * de personajes, delegando la persistencia al GestorGuardado.
 * 
 * @param {GestorGuardado} gestorGuardado - Servicio para cargar personajes
 * @param {NotificadorCLI} notificador - Servicio para mostrar mensajes
 */
async function cargarPersonaje(gestorGuardado, notificador) {
    try {
        // Cargar todos los personajes guardados
        const personajes = await gestorGuardado.cargarPersonajes();
        
        // Validar que existan personajes
        if (personajes.length === 0) {
            notificador.warn('No hay personajes guardados. Crea uno primero.');
            return;
        }

        // Crear opciones para el menÃº de selecciÃ³n
        const opciones = personajes.map(p => ({
            name: `${p.getNombre()} (${p.getClase()} Nv.${p.getNivel()}) - Vida: ${p.getVida()}/${p.getMaxVida()}`,
            value: p.getId()
        }));

        // Permitir al usuario seleccionar un personaje
        const { personajeId } = await inquirer.prompt([{
            type: 'list',
            name: 'personajeId',
            message: 'Selecciona un personaje:',
            choices: opciones
        }]);

        // Encontrar y mostrar informaciÃ³n del personaje seleccionado
        const personaje = personajes.find(p => p.getId() === personajeId);
        notificador.success(`Personaje ${personaje.getNombre()} cargado exitosamente!`);
        
        // Mostrar estado detallado del personaje
        const estado = personaje.estado();
        notificador.info(`Estado: ${estado.nombre} (${estado.clase} Nv.${estado.nivel})`);
        notificador.info(`Vida: ${estado.vida}/${estado.maxVida} | EnergÃ­a: ${estado.energia}/${estado.maxEnergia}`);
        notificador.info(`Ataque: ${estado.ataque} | Defensa: ${estado.defensa} | Velocidad: ${estado.velocidad}`);
        notificador.info(`Experiencia: ${estado.experiencia}/${estado.nivel * 100} | Items: ${estado.inventario}`);

    } catch (error) {
        notificador.error(`Error cargando personaje: ${error.message}`);
    }
}

/**
 * Lista todos los personajes guardados con su informaciÃ³n bÃ¡sica.
 * 
 * Aplica el principio SRP al manejar Ãºnicamente la visualizaciÃ³n
 * de la lista de personajes, delegando la carga al GestorGuardado.
 * 
 * @param {GestorGuardado} gestorGuardado - Servicio para cargar personajes
 * @param {NotificadorCLI} notificador - Servicio para mostrar mensajes
 */
async function listarPersonajes(gestorGuardado, notificador) {
    try {
        // Cargar todos los personajes guardados
        const personajes = await gestorGuardado.cargarPersonajes();
        
        // Validar que existan personajes
        if (personajes.length === 0) {
            notificador.warn('No hay personajes guardados.');
            return;
        }

        // Mostrar encabezado de la lista
        notificador.info('--- Personajes Guardados ---');
        
        // Iterar y mostrar informaciÃ³n de cada personaje
        personajes.forEach(personaje => {
            const estado = personaje.estado();
            notificador.info(`${estado.nombre} (${estado.clase} Nv.${estado.nivel}) - Vida: ${estado.vida}/${estado.maxVida} | Items: ${estado.inventario}`);
        });
        
        // Mostrar pie de la lista
        notificador.info('----------------------------');

    } catch (error) {
        notificador.error(`Error listando personajes: ${error.message}`);
    }
}

/**
 * Inicia una batalla entre el personaje del jugador y un enemigo.
 * 
 * Aplica el principio DIP (Dependency Inversion Principle) al depender
 * de abstracciones (GestorGuardado, GeneradorEnemigos, NotificadorCLI)
 * en lugar de implementaciones concretas.
 * 
 * @param {GestorGuardado} gestorGuardado - Servicio para cargar/guardar datos
 * @param {GeneradorEnemigos} generadorEnemigos - Servicio para generar enemigos
 * @param {NotificadorCLI} notificador - Servicio para mostrar mensajes
 */
async function iniciarBatalla(gestorGuardado, generadorEnemigos, notificador) {
    try {
        // Cargar personajes disponibles
        const personajes = await gestorGuardado.cargarPersonajes();
        
        // Validar que existan personajes
        if (personajes.length === 0) {
            notificador.warn('No hay personajes guardados. Crea uno primero.');
            return;
        }

        // Crear opciones de personajes para selecciÃ³n
        const opciones = personajes.map(p => ({
            name: `${p.getNombre()} (${p.getClase()} Nv.${p.getNivel()})`,
            value: p.getId()
        }));

        // Recopilar configuraciÃ³n de la batalla
        const { personajeId, tipoEnemigo } = await inquirer.prompt([
            {
                type: 'list',
                name: 'personajeId',
                message: 'Selecciona tu personaje:',
                choices: opciones
            },
            {
                type: 'list',
                name: 'tipoEnemigo',
                message: 'Tipo de enemigo:',
                choices: [
                    { name: 'Enemigo Normal', value: 'normal' },
                    { name: 'Boss (mÃ¡s difÃ­cil)', value: 'boss' }
                ]
            }
        ]);

        // Obtener el personaje seleccionado
        const jugador = personajes.find(p => p.getId() === personajeId);
        
        // Generar enemigo segÃºn el tipo seleccionado
        const enemigo = tipoEnemigo === 'boss' 
            ? generadorEnemigos.generarEnemigoBoss(jugador.getNivel())
            : generadorEnemigos.generarEnemigo(jugador.getNivel());

        // Crear y ejecutar la batalla
        const gestorBatalla = new GestorBatalla({ jugador, enemigo, notificador });
        const resultado = await gestorBatalla.iniciar();

        // Persistir resultado de la partida
        await gestorGuardado.guardarPartida({
            jugador: jugador.getNombre(),
            enemigo: enemigo.getNombre(),
            resultado: resultado.tipo,
            turnos: gestorBatalla.turno
        });

        // Guardar personaje actualizado (con experiencia ganada)
        await gestorGuardado.guardarPersonaje(jugador);

    } catch (error) {
        notificador.error(`Error en la batalla: ${error.message}`);
    }
}

/**
 * Muestra estadÃ­sticas generales del juego.
 * 
 * Aplica el principio SRP al manejar Ãºnicamente la visualizaciÃ³n
 * de estadÃ­sticas, delegando la obtenciÃ³n de datos al GestorGuardado.
 * 
 * @param {GestorGuardado} gestorGuardado - Servicio para obtener estadÃ­sticas
 * @param {NotificadorCLI} notificador - Servicio para mostrar mensajes
 */
async function mostrarEstadisticas(gestorGuardado, notificador) {
    try {
        // Obtener estadÃ­sticas del sistema
        const stats = await gestorGuardado.obtenerEstadisticas();
        
        // Mostrar estadÃ­sticas generales
        notificador.info('--- EstadÃ­sticas del Juego ---');
        notificador.info(`Total de personajes: ${stats.totalPersonajes}`);
        notificador.info(`Total de partidas: ${stats.totalPartidas}`);
        
        // Mostrar distribuciÃ³n por clases
        notificador.info('\nPersonajes por clase:');
        Object.entries(stats.personajesPorClase).forEach(([clase, cantidad]) => {
            notificador.info(`  ${clase}: ${cantidad}`);
        });

        // Mostrar partidas recientes si existen
        if (stats.partidasRecientes.length > 0) {
            notificador.info('\nPartidas recientes:');
            stats.partidasRecientes.forEach(partida => {
                const fecha = new Date(partida.fecha).toLocaleString();
                notificador.info(`  ${fecha}: ${partida.jugador} vs ${partida.enemigo} - ${partida.resultado}`);
            });
        }
        
        // Mostrar pie de estadÃ­sticas
        notificador.info('----------------------------');

    } catch (error) {
        notificador.error(`Error obteniendo estadÃ­sticas: ${error.message}`);
    }
}

/**
 * Muestra la ayuda y instrucciones del juego.
 * 
 * Aplica el principio SRP al manejar Ãºnicamente la visualizaciÃ³n
 * de informaciÃ³n de ayuda, sin lÃ³gica de negocio.
 * 
 * @param {NotificadorCLI} notificador - Servicio para mostrar mensajes
 */
function mostrarAyuda(notificador) {
    notificador.info(`
ðŸš€ Galaxy Sprint â€” Batallas Espaciales ðŸš€

OBJETIVO:
Derrota a enemigos espaciales en batallas por turnos para ganar experiencia y subir de nivel.

CLASES DE EXPLORADORES:
â€¢ Humano: Equilibrado, buena versatilidad
â€¢ Guerrero: Tanque con mucha vida y defensa
â€¢ Mago: Poderoso pero frÃ¡gil, usa magia
â€¢ Arquero: RÃ¡pido y Ã¡gil, ataques mÃºltiples

SISTEMA DE BATALLA:
â€¢ Cada turno puedes atacar, usar habilidades especiales, descansar o usar items
â€¢ La velocidad determina el orden de los turnos
â€¢ Gana experiencia al derrotar enemigos
â€¢ Sube de nivel para mejorar tus estadÃ­sticas

ITEMS:
â€¢ Pociones: Restauran vida
â€¢ Bebidas energÃ©ticas: Restauran energÃ­a
â€¢ Armas: Mejoran el ataque
â€¢ Armaduras: Mejoran la defensa

GUARDADO:
â€¢ Tu progreso se guarda automÃ¡ticamente
â€¢ Puedes crear mÃºltiples personajes
â€¢ Las estadÃ­sticas se mantienen entre sesiones

Â¡Disfruta explorando la galaxia! ðŸŒŒ
    `);
}

// Ejecutar la aplicaciÃ³n principal
// Manejo de errores global para capturar cualquier excepciÃ³n no controlada
main().catch(console.error);
